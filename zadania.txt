1. Generator niestandardowego zakresu (custom_range)

Opis dla studentów:

    Zaimplementuj funkcję generatora custom_range(start, end, step), która działa podobnie do wbudowanej funkcji range(). Ma ona generować liczby zaczynając od start, zwiększając (lub zmniejszając) je o step, aż do momentu osiągnięcia wartości granicznej end (nie włącznie).
    Wskazówka: Użyj pętli while oraz słowa kluczowego yield.

2. Nieskończony generator Fibonacciego

Opis dla studentów:

    Stwórz funkcję generatora infinite_fibonacci(), która generuje nieskończony ciąg liczb Fibonacciego. Każde wywołanie next() powinno zwracać kolejną liczbę ciągu: 0, 1, 1, 2, 3, 5, ...
    Wskazówka: Użyj dwóch zmiennych do śledzenia aktualnej i następnej liczby oraz nieskończonej pętli while.

3. Pobierz N elementów z iteratora

Opis dla studentów:

    Napisz funkcję take_n(iterator, n), która pobiera pierwsze n elementów z dowolnego iteratora i zwraca je jako listę. Jeśli iterator się skończy wcześniej, zwróć tyle elementów, ile było dostępnych.
    Wskazówka: Użyj pętli oraz funkcji next() z obsługą wyjątku StopIteration.


4. Czytanie pliku linia po linii (generator)

Opis dla studentów:

    Zaimplementuj funkcję generatora read_file_lines(filepath), która otwiera plik i zwraca po jednej linii przy każdym wywołaniu, usuwając znak końca linii (\n).
    Wskazówka: Skorzystaj z bloku with open(...) oraz pętli for, aby wczytywać linie pojedynczo.

5. Iterowalny obiekt z funkcją podglądu (trudniejsze)

Opis dla studentów:

    Stwórz klasę PeekableIterator, która owija dowolny iterator i umożliwia podejrzenie następnej wartości bez jej pobierania. Metoda peek() powinna zwracać następny element bez przesuwania iteratora, natomiast __next__() ma ten element zwracać i przesuwać iterator dalej.
    Klasa powinna implementować także metodę __iter__().
    Wskazówka: Wykorzystaj wewnętrzne zmienne do buforowania wartości zwróconej przez peek().
